\section{Farward Symbolic Execution} 
Forward symbolic execution allows us to reason about the behavior of a program on many different inputs at one time by building a logical formula that represents a program execution. Thus, reasoning about the behavior of the program can be reduced to the domain of logic.

One of the advantages of forward symbolic execution is that it can be used to reason about more than one input at once. For instance, in this program, only one out of $2^{32}$ possible inputs will cause the program to take the true branch. Forward symbolic execution can reason about the program by considering two different input classes — inputs that take the true branch, and those that take the false branch.

Creating a forward symbolic execution engine is conceptually a very simple process: take the operational semantics of the language and change the definition of a value to include symbolic expressions.

\begin{lstlisting}
x := 2 * get_input(src)
if x - 5 == 14 then goto 3 else goto 4
// catastrophic failure
// normal behaviour
\end{lstlisting}

The primary difference between forward symbolic execution and regular execution is that when \texttt{get\_input(·)} is evaluated symbolically, it returns a symbol instead of a concrete value. When a new symbol is first returned, there are no constraints on its value; it represents any possible value. As a result, expressions involving symbols cannot be fully evaluated to a concrete value. Thus, our language must be modified, allowing a value to be a partially evaluated symbolic expression.

Branches constrain the values of symbolic variables to the set of values that would execute the path. For example, in the program above, if the execution follows the \texttt{true} branch, then \texttt{x} must contain 19. Otherwise \texttt{x} contains a value which is not 19. Every \texttt{if then else} statement creates two partitions of the input domain. The strategy used for choosing paths can significantly impact the quality of the analysis.

\subsection{Challenges and Opportunities}
Unfortunately, by examining our formal definition of this intuition, we can find several instances where our analysis breaks down.

\subsubsection{Path Selection} 
When forward symbolic execution encounters a branch, it must decide which branch to follow first. We call this the \textbf{path selection problem}.

We can think of a forward symbolic execution of an entire program as a tree in which every node represents a particular instance of the abstract machine. The analysis begins with only a root node in the tree. However, every time the analysis must fork, such as when a conditional jump is encountered, it adds as children all possible forked states to the current node. We can further explore any leaf node in the tree that has not terminated. 

Thus, forward symbolic execution needs a strategy for choosing which state to explore next. This choice is important, because loops with symbolic conditions may never terminate. If an analysis tries to explore such a loop in a naive manner, it might never explore other branches in the state tree. Loops can cause trees of infinite depth. Thus, the handling of loops are an integral component in the path-selection strategy.

\begin{center}\texttt{while ($3^{n}$ + $4^{n}$ == $5^{n}$) $\{$n++; ...$\}$}\end{center}


Exploring all paths in this program is infeasible. Although we know mathematically there is no satisfying answer to the branch guard other than 2, the forward symbolic execution algorithm does not.

Furthermore, a straightforward implementation of forward symbolic execution will lead to:
\begin{itemize}
	\item a running time exponential in the number of program branches, because a new interpreter is forked off at each branch point;
	\item an exponential number of formulas, which directly follows from the previous, as there is a separate formula at each branch point;
	\item an exponentially-sized formula per branch due to substitution. During both concrete and symbolic evaluation of an expression \texttt{e}, we substitute all variables in \texttt{e} with their value. However, unlike concrete evaluation, the result of evaluating \texttt{e} is not of constant size.
\end{itemize}
In practice, we can mitigate these problems in a number of ways:
\begin{itemize}
	\item \textbf{Path selection heuristics}:
	\begin{itemize}
		\item \textbf{Depth-First Search}: DFS employs the standard depth-first search algorithm on the state tree. The primary disadvantage of DFS is that it can get stuck in nonterminating loops with symbolic conditions if no maximum depth is specified. If this happens, then no other branches will be explored and code coverage will be low;
		\item \textbf{Random Paths}: this kinds of strategies traverse the state tree from the root until they reach a leaf node. The random path strategy gives a higher weight to shallow states. This prevents executions from getting stuck in loops with symbolic conditions;
		\item \textbf{Concolic Testing}: concolic testing uses concrete execution to produce a trace of a program execution. Forward symbolic execution then follows the same path as the concrete execution. The analysis can optionally generate concrete inputs that will force the execution down another path by choosing a conditional and negating the constraints corresponding to that conditional statement.
	\end{itemize}
	\item \textbf{Use more and faster hardware}. Exploring multiple paths and solving formulas for each path is inherently parallelizable;
	item \textbf{Identify independent subformulas}. By identifying logically independent subformulas and analyze them using SMT solvers. Eventually we can implement caching so that if the same formula is queried multiple times we can use the cached value instead of solving it again;
	\item \textbf{Identify redundancies} between formulas and make them more compact.
\end{itemize}

\subsubsection{Symbolic Memory Addresses}
The \texttt{LOAD} and \texttt{STORE} rules evaluate the expression representing the memory address to a value, and then get or set the corresponding value at that address in the memory context $\mu$. When executing concretely, that value will be an integer that references a particular memory cell.

When executing symbolically, however, we must decide what to do when a memory reference is an expression instead of a concrete number. The symbolic memory address problem arises whenever an address referenced in a load or store operation is an expression derived from user input instead of a concrete value.

When we load from a symbolic expression, a sound strategy is to consider it a load from any possible satisfying assignment for the expression. Similarly, a store to a symbolic address could overwrite any value for a satisfying assignment to the expression. Symbolic addresses are common in real programs, e.g., in the form of table lookups dependent on user input. Symbolic memory addresses can lead to aliasing issues even along a single execution path. A potential address alias occurs when two memory operations refer to the same address.

There are several approaches to dealing with symbolic references:
\begin{itemize}
	\item Make unsound assumptions for removing symbolic addresses from programs. The appropriateness of such unsound assumptions
	varies depending on the overall application domain;
	\item Let the SMT solver reason about all possible aliasing relationships. In order to logically encode symbolic
	addresses, we must explicitly name each memory update;
	\item Perform alias analysis. One could try to reason about whether two references are pointing to the same address	by performing alias analysis. Alias analysis, however, is a static or offline analysis. In many application domains, such as recent work in automated test-case generation, fuzzing, and	malware analysis, part of the allure of forward	symbolic execution is that it can be done at run-time. In such scenarios, adding a static analysis component may be unattractive.
\end{itemize}

The premise of the \texttt{GOTO} rule requires the address expression to evaluate to a concrete value. However, during forward symbolic execution the jump target may be an expression instead of a concrete location. We call this the symbolic jump problem. One common cause of symbolic jumps are jump tables, which are commonly used to implement switch statements. We can solve this problem in a number of ways:
\begin{itemize}
	\item Use concrete and symbolic (concolic) analysis	to run the program and observe an indirect jump target. Once the jump target is taken in the concrete	execution, we can perform symbolic execution of the	concrete path. One drawback is that it becomes more difficult to explore the full-state space of the program because we only explore known jump targets. Thus, code coverage can suffer;
	\item Using an SMT solver. Although querying a SMT solver is a perfectly valid solution, it may not be as efficient as other options that take advantage of program structure, such as static analysis;
	\item Use static analysis. Static analysis can reason about the entire program to locate possible jump targets.
\end{itemize}