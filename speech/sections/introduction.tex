\section{Introduction}
\subsection{Of who or what do we trust?} 
In an ideal world users enter the right inputs and programs are written in the right way, without bugs or vulnerabilities. Unfortunately the real world is bad, very bad. In this world users often enter wrong inputs, both intentionally or not, and programmers write programs in a lazy and vulnerable way. They often don't care about user inputs, and this leads to a lot of software vulnerabilities, like buffer overflow or code injection.

This means that we can't neither trust user nor programmers and we should assume that \textit{everything} is vulnerable. This is why we analyze programs: to discover vulnerabilities. Over the last few years, dynamic analysis has become increasingly popular in security. We run programs and we observe their behavior: that's all.

\subsection{Questions about user input}
Talking about users' inputs, two main questions can arise:

\subsubsection{Is the final value affected by user input? $\Rightarrow$ Dynamic Taint Analysis}
Dynamic taint analysis runs a program and observes which computations are affected by predefined taint sources such as user input. Any program value whose computation depends on data derived from a taint source is considered \textit{tainted}. Any other value is considered untainted.

\subsubsection{What input will make execution reach this line of code? $\Rightarrow$ Forward Symbolic Execution}
Dynamic forward symbolic execution automatically builds a logical formula describing a program execution path, which reduces the problem of reasoning about the execution to the domain of logic.

\subsection{Applications}
The number of security applications utilizing these two techniques is enormous. Example security research areas employing either dynamic taint analysis, forward symbolic execution, or a mix of the two, are the following:
\begin{itemize}
	\item \textbf{Unknown Vulnerability Detection}: Dynamic taint analysis can look for misuses of user input during an execution. For example, dynamic taint analysis can be used to prevent code injection attacks by monitoring whether user input is executed;
	\item \textbf{Automatic Input Filter Generation}: Forward symbolic 	execution can be used to automatically generate input filters that detect and remove exploits from the input stream. Filters generated in response to actual executions are attractive because they provide strong accuracy guarantees;
	\item \textbf{Malware Analysis}: Taint analysis and forward symbolic execution are used to analyze how information flows through a malware binary, explore trigger-based behavior and detect emulators;
	\item \textbf{Test Case Generation}: Taint analysis and forward symbolic execution are used to automatically generate inputs to test programs, and can generate inputs that cause two implementations of the same protocol to behave differently.
\end{itemize}
