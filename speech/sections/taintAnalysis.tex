\section{Dynamic Taint Analysis}
The purpose of dynamic taint analysis is to track information flow between sources and sinks. Any program value whose computation depends on data derived from a taint source is considered tainted (denoted \textbf{T}). Any other value is considered untainted (denoted \textbf{F}). We can represent this taint marker with a single bit.

\subsection{Policies}
A taint policy \textbf{P} determines exactly how taint flows as a program executes, what sorts of operations introduce new taint, and what checks are performed on tainted values. The specifics of the taint policy may differ depending upon the taint analysis application, e.g., taint tracking policies for unpacking malware may be different than attack detection.

A taint policy specifies three properties: how new taint is introduced to a program, how taint propagates as instructions execute, and how taint is checked during execution:
\begin{itemize}
	\item \textbf{Taint Introduction}: taint introduction rules specify how taint is introduced into a system. The typical convention is to initialize all variables, memory cells, etc. as untainted. In SimpIL, we only have a single source of user input: the get\_input(Â·) call. A taint policy will also typically distinguish between different input sources. For example, an internet-facing network input source may always introduce taint, while a file descriptor that reads from a trusted configuration file may not;
	\item \textbf{Taint Propagation}: taint propagation rules specify the taint status for data derived from tainted or untainted operands. Since taint is a bit, propositional logic is usually used to express the propagation policy, e.g., t1 $\lor$ t2 indicates the result is tainted if t1 is tainted or t2 is tainted;
	\item \textbf{Taint Checking}: taint status values are often used to determine the runtime behavior of a program, e.g., an attack detector may halt execution if a jump target address is tainted. We can perform this check adding the policy to the operational semantics. Thus, we compute a rule iff the status is correct according to the policy.
\end{itemize}

Two types of errors can occur in dynamic taint analysis, according to the selected policy. First, dynamic taint analysis can mark a value as tainted when it is not derived from a taint source. We say that such a value is \textbf{overtainted}. For example, in an attack detection application overtainting will typically result in reporting an attack when no attack occurred. Second, dynamic taint analysis can miss the information flow from a source to a sink, which we call \textbf{undertainting}. In the attack detection scenario, undertainting means the system missed a real attack. A dynamic taint analysis system is \textbf{precise} if no undertainting or overtainting occurs.